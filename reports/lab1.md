## CH3 实现`sys_task_info`

### 遇到的问题

time的计算问题，每个Task记录一个最开始被调用的时间，然后被查询的时候取当前时间减去这个初始时间即可。time在用户态实现返回的是ms，但是在内核里面访问是us，所以内核里面建议直接调用get_time_ms。

Rust的代码规范，TaskManager这个结构虽然是全局的，但是采取面向对象的编程方法，不能向外暴露自己的内部信息，所以需要在内部实现函数，这个函数是对外的。设计了3个函数，一个是读取当前running的Task的起始时间，读取当前running task的syscall times这个数组，以及增加syscall_id对这个系统调用的次数。都是对TaskManager这个结构进行实现。

在记录系统调用次数的时候，在用户陷入内核，即将进行具体系统调用的时候来增加次数。这也是为什么用户态println，会导致write系统调用+1，而在内核调用不会+1。注意换行符需要一次额外的系统调用。

存在的问题：如果不对运行的Task进行询问，可能需要遍历Taskmanager的tasks数组。另外我们的syscall_times数组的实现比较丑陋，每个Task都会维护一个这样长度为500的组，且调用的时候采取了复制的策略，导致开销较大。
