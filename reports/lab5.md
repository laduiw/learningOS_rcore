### CH8 并发

这里主要实现银行家算法，也就是每个资源分配之前检查一下是否存在一条执行路径，使得所有线程都能得到自己的资源顺利退出。实验主要处理mutex和信号量，且分开考虑二者的死锁。这里我们考虑每一次分配资源时候都需要检查是否有这样的执行路径存在。最重要的两部分是如何构建矩阵和判断死锁。注意这里虽然不需要完成usertest，但是get_time系统调用需要完成，不然sleep不能调用。

两种思路，第一种是对于资源而言记录他的所有者，第二种是每个线程记录其拥有的资源。第一种思路不易实现，因为每次分配都是一个二元组，最后检查起来构建矩阵比较麻烦，所以采用第二种思路，在TCB中增加相应的资源管理。我们主要针对资源增加了两种记录，分别是apply申请记录和allocated分配记录，这里因为资源总是一个一个分配，所以只要在申请资源的线程上记录申请资源的id即可，首先对于一次申请，将其加入apply队列中，然后生成work，need和allocation矩阵，生成的方法是need矩阵由申请队列完成，检查到一次申请就加一；work初始化为信号量的初值，然后遍历allocated队列，存在一次分配对应资源量减一，allocation对应位置加一，这样便生成了三个矩阵，写一个check函数利用银行家算法判断是否存在一条执行路径即可。如果不会死锁，则分配资源(sem_down)，然后将apply序列中的资源序号移动到allocated中，如果会死锁，那么返回dead并把apply对应项删除。
